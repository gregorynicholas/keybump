#!/usr/bin/env python
"""
  keybump
  ~~~~~~~

  an opinionated script for managing version releases in a github project
  and following the semantic versioning specification.

  :copyright: (c) 2015 by gregorynicholas.
  :license: MIT, see LICENSE for more details.
"""
import re
import sys
import yaml
from os import getcwd
from os import path
from sys import exit
from datetime import datetime
from optparse import OptionParser
from keybump_formatter import *
from keybump_git_utils import *
from keybump_shell_utils import *
from keybump_package_utils import *


DEFAULT_CONFIG_FILE = ".keybump.yaml"
DEFAULT_SKIP_INTERACTIVE = False
DEFAULT_SKIP_SET_INIT_PY_VERSION = False
DEFAULT_SKIP_SET_SETUP_PY_VERSION = False
DEFAULT_SKIP_TAG = False
DEFAULT_SKIP_PUSH = False
DEFAULT_SKIP_COMMIT = False
DEFAULT_PYPI_DISTRIBUTE = True
DEFAULT_CHANGELOG_FILE = "CHANGES.md"
DEFAULT_TAG_MSG_FMT = "Version bumped to {version_num}"
DEFAULT_COMMIT_MSG_FMT = "Version bumped to {version_num}"
SUMMARY_SEPARATOR = "-"
INITIAL_VERSION_NUM = "0.0.0"
INITIAL_VERSION_SUMMARY_ITEM = "initial version setup"
DEFAULT_SUMMARY_ITEM_PREFIX = "    * "
DEFAULT_DATESTR_FMT = "%Y-%m-%d"
DEFAULT_CHANGELOG_FMT = """
Version {version_num}
----------------------

Released on {datestr}

{summaries}

"""
MAJOR_BUMP = "major"
MINOR_BUMP = "minor"
PATCH_BUMP = "patch"
BUMP_TYPES = [MAJOR_BUMP, MINOR_BUMP, PATCH_BUMP]
BANNER = """
edit the changelog summaries. press <enter> to complete:
========================================================
"""
INFO_FMT = """project version information:

  latest tag:   {}
  current tag:  {}
  version id:   {}"""

version_re = re.compile("^Version\s+(.*)")
release_header_re = re.compile(
  "Released on (\d+-\d+-\d+)(?:, codename (.*))?(?i)")


class SummaryFormatter(BaseSummaryFormatter):
  """
  commit summary formatter.
  """

  def __init__(self, *args):
    BaseSummaryFormatter.__init__(self, *args)


class KeybumpConfig(dict):
  """
  class representing a configuration dict.
  """

  @classmethod
  def from_cli_options(cls, options):
    rv = cls(
      bump_type=options.bump_type,
      skip_interactive=options.skip_interactive,
      skip_set_init_py_version=options.skip_set_init_py_version,
      skip_set_setup_py_version=options.skip_set_setup_py_version,
      skip_tag=options.skip_tag,
      skip_push=options.skip_push,
      skip_commit=options.skip_commit,
      pypi_distribute=options.pypi_distribute,
      changelog_file=options.changelog_file,
      changelog_fmt=options.changelog_fmt,
      commit_msg_fmt=options.commit_msg_fmt,
      summaryitem_fmt=options.summaryitem_fmt,
      tag_msg_fmt=options.tag_msg_fmt)
    if options.config_file:
      rv.load(options.config_file)
    return rv

  def __init__(self, *args, **kw):
    self.bump_type = None
    self.skip_interactive = DEFAULT_SKIP_INTERACTIVE
    self.skip_tag = DEFAULT_SKIP_TAG
    self.skip_push = DEFAULT_SKIP_PUSH
    self.skip_commit = DEFAULT_SKIP_COMMIT
    self.pypi_distribute = DEFAULT_PYPI_DISTRIBUTE
    self.changelog_file = DEFAULT_CHANGELOG_FILE
    self.changelog_fmt = DEFAULT_CHANGELOG_FMT
    self.summaryitem_fmt = DEFAULT_SUMMARY_ITEM_PREFIX
    self.commit_msg_fmt = DEFAULT_COMMIT_MSG_FMT
    self.tag_msg_fmt = DEFAULT_TAG_MSG_FMT
    dict.__init__(self, *args)
    self.update(*args, **kw)

  def update(self, *values, **kw):
    if values:
      for k, v in values.iteritems():
        setattr(self, k, v)
    for k, v in kw.iteritems():
      setattr(self, k, v)
    return dict.update(self, values, **kw)

  def load(self, config_file):
    config_file = self._find(config_file)
    if config_file:
      self.update(yaml.load(config_file))

  def _find(self, config_file):
    if config_file:
      if path.exists(config_file):
        return config_file
    else:
      # find a default configuration file either in the home dir or current
      # working dir..
      config_file = path.expanduser("~/{}".format(DEFAULT_CONFIG_FILE))
      if path.exists(config_file):
        return config_file
      else:
        config_file = path.join(getcwd(), DEFAULT_CONFIG_FILE)
        if path.exists(config_file):
          return config_file


class Project(object):
  """
  class representing a project object.
  """

  def __init__(self, config=None):
    """
      :param changelog_file: string for the changelog file path
      :param skip_interactive:
    """
    self.config = config
    self.changelog = Changelog(config.changelog_file)
    self.skip_interactive = config.skip_interactive
    self.changelog_fmt = config.changelog_fmt
    self.commit_msg_fmt = config.commit_msg_fmt
    self.tag_msg_fmt = config.tag_msg_fmt
    self.summaryitem_fmt = config.summaryitem_fmt
    self.summaryformatter = None

    self.releases = []
    self.tags = []
    self.current_tag = None
    self.last_version_num = INITIAL_VERSION_NUM
    self.initial_version_summary_item = INITIAL_VERSION_SUMMARY_ITEM

  @property
  def codename(self):
    if self.last_release:
      return self.last_release.codename

  @property
  def last_release(self):
    if self.release_count > 0:
      return self.releases[-1]

  @property
  def release_count(self):
    return len(self.releases)

  def parse_git_tags(self):
    """
    loads the repo's git tags, sets the `current_tag` + `latest_tag` attrs.
    """
    self.tags = get_git_tags()
    # what to do on first time run? no tags yet..
    if len(self.tags) < 1:
      fail("""create a tag for version: 0.0.0 and try again.. sorry, we're
  still ghetto-riggin this script along.. workin on it..""")
      # todo: implement condition for new project without tags / version.
      # https://github.com/gregorynicholas/keybump/issues/2
    self.latest_tag = get_latest_git_tag()
    # print 'get_latest_git_tag:', get_latest_git_tag()
    self.current_tag = self._current_or_last_git_tag()

  def _current_or_last_git_tag(self):
    """
    returns string name of the current or last git tag.
    """
    rv = get_current_git_tag()
    if rv not in self.tags:
      rv = self.latest_tag
    return rv

  def parse_versions(self):
    if not self.current_tag or len(self.current_tag) < 1:
      return
    non_decimal = re.compile(r"[^\d.]+")
    try:
      self.last_version_num = non_decimal.sub("", self.current_tag)
    except TypeError, e:
      print 'TypeError:', e, self.current_tag
      raise e
    except Exception, e:
      raise e

  def parse_releases(self):
    """
    sets the releases property, parsed from the changelog summaries.
    """
    self.releases = self.parse_changelog_to_releases()
    if len(self.releases) < 1:
      self.setup_initial_release()

  def parse_changelog_to_releases(self):
    """
    parses the contents of the changelog file, and returns a list of `Release`
    objects from the changelog summary.

      :returns: list of instance of a `Release` objects.
    """
    result = []
    # todo: need to handle encoding..
    with self.changelog.open() as f:
      lineiter = iter(f)
      hasdata = False
      for line in lineiter:
        hasdata = True

        # parse the last version..
        ver_match = version_re.search(line.strip())
        if ver_match is None:
          continue
        version_num = ver_match.group(1).strip()
        value = lineiter.next()
        if not value.count(SUMMARY_SEPARATOR):
          continue

        # parse the release data and codename..
        while 1:
          release_header = lineiter.next().strip()
          if release_header:
            break
        rel_match = release_header_re.search(release_header)
        if rel_match is None:
          # todo: raise exception here?
          continue
        datestr, codename = rel_match.groups()

        # parse the change summary messages..
        summaries = []
        while 1:
          try:
            summary = lineiter.next()
          except StopIteration:
            break
          if summary:
            if len(summary.strip()) > 0:
              # strip summary_item_fmt front beginning of item..
              l = len(self.summaryitem_fmt)
              if summary[0:l] == self.summaryitem_fmt:
                summary = summary[l:]
              # remove newline char at end..
              summaries.append(summary[:-1])
          else:
            break

        result.append(Release(
          self, version_num, datestr=datestr, summaries=summaries))

      if len(result) == 0 and hasdata:
        fail("""unable to parse the changelog contents.

        format not recognized by parser.""")
      return result


  def setup_initial_release(self):
    """
    """
    msg = "could not parse release from changelog history in {}.".format(
      self.changelog.path)
    # fail and exit..
    if self.skip_interactive:
      fail(msg)
    # don't fail, set to initial version..
    info(msg)
    if not choice("""
  that's beacuse the file is empty. do you want keybump to
  setup the initial release?"""):
      fail(msg)
    info("""
  ok, you asked for it..
    """)
    rel = self.create_initial_release(self.last_version_num)
    self.changelog.write(rel.format_changelog_summary())
    self.releases.append(rel)

  def create_initial_release(self, version_num):
    """
    creates a default initial release of 0.0.0
    """
    rel = Release(
      self, version_num, datestr=today_str(),
      summaries=[self.initial_version_summary_item])
    return rel

  def new_release(self):
    """
      :returns: instance of a `Release` object.
    """
    rv = Release(
      self, self.last_release.version_num, datestr=today_str())
    rv.bump()
    if rv.version_num in self.tags:
      fail("version `{}` is already tagged", rv.version_num)
    rv.set_summaries(
      self.get_changelog_summaries_since(self.current_tag))
    return rv

  def get_changelog_summaries_since(self, latest_tag):
    """
      :param latest_tag:
      :returns: string list of git commit messages between the `latest_tag`
        and the latest commit
    """
    sep = "__||__"
    rv = sh("git log --no-merges --pretty=%B{} {}..", sep, latest_tag)
    return [x.strip() for x in rv.split(sep)]


  def __str__(self):
    return INFO_FMT.format(
      self.latest_tag, self.current_tag, self.last_version_num)


class Changelog(object):
  """
  class representing a changelog object.
  """

  def __init__(self, filepath, formatter=None, parser=None):
    self.path = filepath
    self.formatter = formatter
    self.parser = parser

  def open(self, mode="r"):
    return open(self.path, mode)

  def write(self, data):
    write(self.path, data)

  def prepend(self, data):
    contents = ""
    with self.open() as f:
      if isinstance(data, basestring):
        contents = data + "\n" + f.read()
      else:
        contents = f.readlines()
    write(self.path, contents)


class Release(object):
  """
  class representing a version release.
  """

  def __init__(self, project, version_num, datestr=None, summaries=None):
    """
      :param version_num: string version in the format: [x].[x].[x]
    """
    self.project = project
    self.version_num = version_num or INITIAL_VERSION_NUM
    self.set_date(datestr)
    self.set_summaries(summaries or [])
    self.codename = project.codename

  @property
  def tag_msg(self):
    return self.project.tag_msg_fmt.format(self.version_num)

  @property
  def commit_msg(self):
    return self.project.commit_msg_fmt.format(
      version_num=self.version_num,
      datestr=self.datestr)

  @property
  def datestr(self):
    return self.date.strftime(DEFAULT_DATESTR_FMT)

  def set_date(self, datestr=None):
    """
      :param datestr: string date in the format: %Y-%m-%d. defaults to today.
    """
    self.date = self._parse_datestr(datestr or today_str())

  def _parse_datestr(self, datestr):
    """
      :param datestr: string date in the format: %Y-%m-%d
      :returns: `datetime.date` object parsed from the `datestr` param
    """
    date_clean_re = re.compile(r"(\d+)(st|nd|rd|th)")
    datestr = date_clean_re.sub(r"\1", datestr)
    return datetime.strptime(datestr, DEFAULT_DATESTR_FMT)

  def set_summaries(self, summaries):
    """
      :param summaries:
    """
    self.summaries = self._format_summary_items(summaries)

  def _format_summary_items(self, summaries):
    """
    cleans summary lines of text. removes merge commit messages.

      :param summaries:
      :returns:
    """
    MIN_SUMMARY_LENGTH = 10
    SKIP_PREFIXES = ["MERGE BRANCH", "MERGE PULL REQUEST"]
    SKIP_EQUALITY = ["WHITESPACE"]
    rv = []
    for line in summaries:
      # merge commits..
      lu = line.upper()
      for skip in SKIP_PREFIXES:
        if lu.startswith(skip):
          continue
      for skip in SKIP_EQUALITY:
        if lu == skip:
          continue
      if len(lu) < MIN_SUMMARY_LENGTH:
        continue
      rv.append(line)
    return rv

  def format_changelog_summary(self):
    """
      :returns: formatted string of the release changelog summary.
    """
    return self.project.changelog_fmt.format(
      version_num=self.version_num,
      datestr=self.datestr,
      summaries=formatjoin(self.project.summaryitem_fmt, self.summaries))

  def _bump_num(self, version_num, bump_type=PATCH_BUMP):
    """
      :param version_num: string version name.
      :param bump_type: version bump type. one of:
          major  [x].0.0    minor  x.[x].0    patch  x.x.[x]
      :returns: concatenated string of the incremented version name.
    """
    # split the version number into a list of ints..
    try:
      version = [int(v) for v in version_num.split(".")]
      switch = {
        "major": lambda: [version[0] + 1, 0, 0],
        "minor": lambda: [version[0], version[1] + 1, 0],
        "patch": lambda: [version[0], version[1], version[2] + 1]}
      return ".".join(map(str, switch.get(bump_type)()))
    except ValueError:
      fail("version string: {} is an invalid format..", version_num)

  def bump(self, bump_type=PATCH_BUMP):
    """
      :param bump_type: version bump type. one of:
          major  [x].0.0    minor  x.[x].0    patch  x.x.[x]
    """
    self.version_num = self._bump_num(self.version_num, bump_type)

  def __str__(self):
    return """"
  previous release: {} (codename: {}, date: {})
  creating release: {} (codename: {}, date: {})
  """.format(
     self.project.last_release.version_num, self.project.codename,
     self.project.last_release.date,
     self.version_num, self.codename, self.date)


# util helpers..


def formatjoin(format, items):
  return format + ("\n" + format).join(items)


def today_str():
  return datetime.now().strftime(DEFAULT_DATESTR_FMT)


# entry point..


def main(options, args):
  config = KeybumpConfig.from_cli_options(options)
  project = Project(config)
  project.parse_git_tags()
  project.parse_versions()
  project.parse_releases()

  if not config.bump_type:
    info(project)
    exit(0)

  ensure_clean_index(config.skip_interactive)

  # increment the version..
  new_release = project.new_release()

  # print the diff
  info(new_release)

  # todo: add optional step to add a separate [version]-dev..
  # https://github.com/gregorynicholas/keybump/issues/3
  # setup the dev new version..
  # dev_version = new_version + '-dev'

  changelog_summary = new_release.format_changelog_summary()

  # todo: add inline changelog summary editing..
  # https://github.com/gregorynicholas/keybump/issues/4
  # present string to user to customize before continuing..
  # if not config.skip_interactive:
  #   readline.set_startup_hook(
  #     lambda: readline.insert_text(changelog_summary))
  #   changelog_summary = input(BANNER)

  # add the release changelog summary to the changelog file..
  project.changelog.prepend(changelog_summary)

  if not config.skip_interactive:
    # todo: add ANSI/colorama and remove excess chars..
    if not choice("""
  ========================================================
  review + edit changelog summary file: {}.

  when satisfied, save the uncommitted file and enter a response below to
  continue or not.


  continue with the release bump?""".format(project.changelog_file)):
      fail("keybump exiting..")
      # todo: rollback flow here?
      # checkout changed files..?

  # todo: rollback flow here?

  # optional step to set python __init__.py version..
  if not config.skip_set_init_py_version:
    set_init_py_version(new_version)

  # optional step to set python setup.py version..
  if not config.skip_set_setup_py_version:
    set_setup_py_version(new_version)

  if not config.skip_commit:
    make_git_commit(config.changelog_file, new_release.tag_msg)

  if not config.skip_tag:
    make_git_tag(new_release.tag_msg, new_release.version_num)

  if not config.skip_push:
    push_to_remote()

  info("""
  ========================================================
  release complete: {}.
  """.format(new_release.tag_msg))

  # optional pypi releases..

  if not config.pypi_distribute:
    setup_distribute()
    info("version built + released and uploaded to python package index..")

  project.releases.append(new_release)
  exit(0)


parser = OptionParser(
  description="description: keybump makes following the semantic versioning "
 "specification a breeze. \n"
 "if called with no options, keybump will print the current git repository's "
 "tag + version name",
  prog="keybump",
  usage="%progs [options]")

parser.add_option(
  "--config", dest="config_file",
  default=DEFAULT_CONFIG_FILE,
  help="path to a keybump configuration file.")

parser.add_option(
  "--skip-interactive", dest="skip_interactive", action="store_true",
  default=DEFAULT_SKIP_INTERACTIVE,
  help="skips interactive command line interface.")

parser.add_option(
  "--bump", dest="bump_type", choices=BUMP_TYPES,
  help="""version bump type to increment. must be
  one of:
    major [x].x.x
    minor x.[x].x
    patch x.x.[x]""")

parser.add_option(
  "--skip-set-init-py", dest="skip_set_init_py_version", action="store_true",
  default=DEFAULT_SKIP_SET_INIT_PY_VERSION,
  help="skips setting the new version string in the project root's __init__.py")

parser.add_option(
  "--skip-set-setup-py", dest="skip_set_setup_py_version", action="store_true",
  default=DEFAULT_SKIP_SET_SETUP_PY_VERSION,
  help="skips setting the new version string in the setup.py")

parser.add_option(
  "--skip-commit", dest="skip_commit", action="store_true",
  default=DEFAULT_SKIP_COMMIT,
  help="skips creating a git tag at the current HEAD")

parser.add_option(
  "--skip-tag", dest="skip_tag", action="store_true", default=DEFAULT_SKIP_TAG,
  help="skips creating a git tag at the current HEAD")

parser.add_option(
  "--skip-push", dest="skip_push", action="store_true",
  default=DEFAULT_SKIP_PUSH,
  help="skips pushing to the remote origin")

parser.add_option(
  "--pypi-dist", dest="pypi_distribute", action="store_true",
  default=DEFAULT_PYPI_DISTRIBUTE,
  help="build the release and upload to the python package index")

# todo: implement message formats as cli options..
# https://github.com/gregorynicholas/keybump/issues/5

parser.add_option(
  "--changelog-file", dest="changelog_file", default=DEFAULT_CHANGELOG_FILE,
  help="path to the changelog history file.")

parser.add_option(
  "--changelog-fmt", dest="changelog_fmt", default=DEFAULT_CHANGELOG_FMT,
  help="string format of the changelog version summary")

parser.add_option(
  "--summaryitem-fmt", dest="summaryitem_fmt",
  default=DEFAULT_SUMMARY_ITEM_PREFIX,
  help="string format of a changelog item summary")

parser.add_option(
  "--git-commit-fmt", dest="commit_msg_fmt", default=DEFAULT_COMMIT_MSG_FMT,
  help="string format of the git commit message")

parser.add_option(
  "--git-tag-fmt", dest="tag_msg_fmt", default=DEFAULT_TAG_MSG_FMT,
  help="string format of the git tag")


if __name__ == "__main__":
  main(*parser.parse_args())
